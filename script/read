VM
Виртуальная машина (VM, от англ. virtual machine) — программная и/или аппаратная система, эмулирующая аппаратное обеспечение некоторой платформы (target — целевая, или гостевая платформа) и исполняющая программы для target-платформы на host-платформе (host — хост-платформа, платформа-хозяин) или виртуализирующая некоторую платформу и создающая на ней среды, изолирующие друг от друга программы и даже операционные системы (см.: песочница); также спецификация некоторой вычислительной среды (например: «виртуальная машина языка программирования Си»).
Виртуальная машина исполняет некоторый машинно-независимый код (например, байт-код, шитый код, p-код) или машинный код реального процессора. Помимо процессора, ВМ может эмулировать работу как отдельных компонентов аппаратного обеспечения, так и целого реального компьютера (включая BIOS, оперативную память, жёсткий диск и другие периферийные устройства). В последнем случае в ВМ, как и на реальный компьютер, можно устанавливать операционные системы (например, Windows можно запускать в виртуальной машине под Linux или наоборот). На одном компьютере может функционировать несколько виртуальных машин (это может использоваться для имитации нескольких серверов на одном реальном сервере с целью оптимизации использования ресурсов сервера).


FLOAT
Известно, что целых чисел бесконечно много, строго говоря, счетно много. Понятно, что возможностей компьютера хватит лишь на то, чтобы хранить конечное число чисел из ограни­ ченного диапазона.
Одним из вариантов представления вещественных чисел в компьютере является использование формата с фиксированной запятой. Рассмотрим вариант, когда для хранения веществен­ ного числа отведено два байта. Естественно один отвести для хранения целой части, а другой — дробной.

Все числа кроме нуля могут быть записаны в так называе­ мой научной нотации: например, число 5243.17 = 5.24317 •103, или —0.00021 = —2 . 1 • 10~4, или 1 = 1.0 • 10°. Эта запись вклю­ чает в себя:
знак +/-;
мантиссу, состоящую из ровно одной ведущей цифры, не равной нулю, и дробной части, которая может быть нулевой;
степень, в основании которой стоит база системы счисле­ ния, показатель степени называют порядком.

Согласно стандарту IEEE 754, для хранения вещественных чисел отводится 4 байта: из них 1 бит для знака, 8 бит для по­ рядка (который может быть как положительным, так и отрица­ тельным) и 23 бита для «усеченной» мантиссы. Формат предпо­ лагает хранение нормализованных чисел, двух нулей (положи­ тельного и отрицательного), денормализованных чисел и ис­ ключений (плюс и минус бесконечность и не числа2).


BM
пецифика алгоритма Бойера-Мура состоит в том, что за счет предварительной обработки шаблона Т и специальным образом организованного процесса сопоставления шаблона и фрагмента строки S удастся пропустить некоторые символы (а иногда и весьма длинные последовательности символов1) стро­ ки S как заведомо не дающие совпадения с шаблоном Т.
На очередном шаге алгоритма пытаемся сопоставить фраг­ мент і5[г.. і + m —1], 1 < г < п —771+ 1, с шаблоном Т. В част­ ности, на первом шаге пытаемся сопоставить S [l..m ] и Г. Со­ поставление начнем с конца фрагмента S'[г.. г 4- m —1] и будем двигаться к его началу. Причина в том, что сопоставление с конца дает в отдельных случаях больше информации, нежели если делать сравнение с начала (т. е. с левого конца), и позво­ ляет совершать «длинные прыжки» по строке S.


Hamming
Код Хэ́мминга — самоконтролирующийся и самокорректирующийся код. Построен применительно к двоичной системе счисления.
Позволяет исправлять одиночную ошибку (ошибка в одном бите слова) и находить двойную.
Назван в честь американского математика Ричарда Хэмминга, предложившего код.

Систематические коды образуют большую группу из блочных, разделимых кодов (в которых все символы слова можно разделить на проверочные и информационные). Особенностью систематических кодов является то, что проверочные символы образуются в результате линейных логических операций над информационными символами. Кроме того, любая разрешенная кодовая комбинация может быть получена в результате линейных операций над набором линейно независимых кодовых комбинаций.
Коды Хэмминга являются самоконтролирующимися кодами, то есть кодами, позволяющими автоматически обнаруживать ошибки при передаче данных. Для их построения достаточно приписать к каждому слову один добавочный (контрольный) двоичный разряд и выбрать цифру этого разряда так, чтобы общее количество единиц в изображении любого числа было, например, нечетным. Одиночная ошибка в каком-либо разряде передаваемого слова (в том числе, может быть, и в контрольном разряде) изменит четность общего количества единиц. Счетчики по модулю 2, подсчитывающие количество единиц, которые содержатся среди двоичных цифр числа, дают сигнал о наличии ошибок.
При проверочном бите этом невозможно узнать, в какой именно позиции слова произошла ошибка, и, следовательно, нет возможности исправить её. Остаются незамеченными также ошибки, возникающие одновременно в двух, четырёх, и т. д. — в четном количестве разрядов. Предполагается, что двойные, а тем более многократные ошибки маловероятны.
Коды, в которых возможно автоматическое исправление ошибок, называются самокорректирующимися. Для построения самокорректирующегося кода, рассчитанного на исправление одиночных ошибок, одного контрольного разряда недостаточно. Как видно из дальнейшего, количество контрольных разрядов k должно быть выбрано так, чтобы удовлетворялось неравенство 2 k ≥ k + m + 1 или k ≥ log 2 (k + m + 1), где m — количество информационных двоичных разрядов кодового слова.

Диапазон m	kmin
1	    2
2-4	    3
5-11	4
12-26	5
27-57	6
Минимальные значения k при заданных значениях m, найденные в соответствии с этим неравенством, приведены в таблице.

Наибольший интерес представляют двоичные блочные корректирующие коды. При использовании таких кодов информация передаётся в виде блоков одинаковой длины и каждый блок кодируется и декодируется независимо друг от друга. Почти во всех блочных кодах символы можно разделить на информационные и проверочные или контрольные. Таким образом, все слова разделяются на разрешенные (для которых соотношение информационных и проверочных символов возможно) и запрещенные.


Haffman
Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. В настоящее время используется во многих программах сжатия данных.

В отличие от алгоритма Шеннона — Фано, алгоритм Хаффмана остаётся всегда оптимальным и для вторичных алфавитов m2 с более чем двумя символами.
Этот метод кодирования состоит из двух основных этапов:
1. Построение оптимального кодового дерева.
2. Построение отображения код-символ на основе построенного дерева.

Классический алгоритм Хаффмана на входе получает таблицу частот встречаемости символов в сообщении. Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево).
1. Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
2. Выбираются два свободных узла дерева с наименьшими весами.
3. Создается их родитель с весом, равным их суммарному весу.
4. Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
5. Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
6. Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.


ЦЕЗАРЬ
Шифр Цезаря, также известный как шифр сдвига, код Цезаря или сдвиг Цезаря — один из самых простых и наиболее широко известных методов шифрования.
Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите. Например, в шифре со сдвигом вправо на 3, А была бы заменена на Г, Б станет Д, и так далее.
Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки со своими генералами.
Шаг шифрования, выполняемый шифром Цезаря, часто включается как часть более сложных схем, таких как шифр Виженера, и всё ещё имеет современное приложение в системе ROT13. Как и все моноалфавитные шифры, шифр Цезаря легко взламывается и не имеет почти никакого применения на практике.


